package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"time_speak_server/graph/generated"
	"time_speak_server/src/exception"
	"time_speak_server/src/opts"
	"time_speak_server/src/service/hashtag"
	"time_speak_server/src/service/memory"
	"time_speak_server/src/service/user"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// ID is the resolver for the id field.
func (r *memoryResolver) ID(ctx context.Context, obj *memory.Memory) (string, error) {
	return obj.ObjectID.Hex(), nil
}

// User is the resolver for the user field.
func (r *memoryResolver) User(ctx context.Context, obj *memory.Memory) (*user.User, error) {
	u, err := r.userSvc.GetUser(ctx, obj.Uid)
	if err != nil {
		return nil, err
	}
	return &u, nil
}

// Hashtags is the resolver for the hashtags field.
func (r *memoryResolver) Hashtags(ctx context.Context, obj *memory.Memory) ([]*hashtag.HashTag, error) {
	var tags []*hashtag.HashTag
	for _, t := range obj.HashTags {
		tag, err := r.hashtagSvc.GetHashTagByID(ctx, t)
		if err != nil {
			return nil, err
		}
		tags = append(tags, tag)
	}
	return tags, nil
}

// AddMemory is the resolver for the addMemory field.
func (r *mutationResolver) AddMemory(ctx context.Context, input generated.AddMemoryInput) (string, error) {
	// @auth
	if len(input.Content) == 0 {
		return "", exception.ErrContentEmpty
	}
	tags, err := r.hashtagSvc.MakeHashTags(ctx, input.Content)
	if err != nil {
		return "", err
	}
	newMemory, err := r.memorySvc.NewMemory(ctx, input.Title, input.Content, tags)
	if err != nil {
		return newMemory, err
	}
	err = r.resourceSvc.UpdateReferences(ctx, "", input.Content, newMemory)
	if err != nil {
		return newMemory, err
	}
	return newMemory, nil
}

// UpdateMemory is the resolver for the updateMemory field.
func (r *mutationResolver) UpdateMemory(ctx context.Context, input generated.UpdateMemoryInput) (bool, error) {
	if len(input.Content) == 0 {
		return false, exception.ErrContentEmpty
	}
	tags, err := r.hashtagSvc.MakeHashTags(ctx, input.Content)
	if err != nil {
		return false, err
	}
	id, err := primitive.ObjectIDFromHex(input.ID)
	if err != nil {
		return false, exception.ErrInvalidID
	}
	var toUpdate []opts.Option
	if len(input.Title) > 0 {
		toUpdate = append(toUpdate, opts.WithTitle(input.Title))
	}
	if len(input.Content) > 0 {
		toUpdate = append(toUpdate, opts.WithContent(input.Content))
		toUpdate = append(toUpdate, opts.WithTags(tags))
	}
	if len(toUpdate) == 0 {
		return true, nil
	}
	oldMemory, err := r.memorySvc.GetMemory(ctx, id)
	if err != nil {
		return false, err
	}
	// 更新 History
	_, err = r.historySvc.NewHistory(ctx, oldMemory)
	if err != nil {
		return false, err
	}
	// 更新 Resource
	err = r.resourceSvc.UpdateReferences(ctx, oldMemory.Content, input.Content, input.ID)
	if err != nil {
		return false, err
	}
	// 更新 Memory
	err = r.memorySvc.UpdateMemory(ctx, id, toUpdate...)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ArchiveMemory is the resolver for the archiveMemory field.
func (r *mutationResolver) ArchiveMemory(ctx context.Context, input string, archived bool) (bool, error) {
	id, err := primitive.ObjectIDFromHex(input)
	if err != nil {
		return false, exception.ErrInvalidID
	}
	toUpdate := opts.WithArchived(archived)
	err = r.memorySvc.UpdateMemory(ctx, id, toUpdate)
	return true, nil
}

// DeleteMemory is the resolver for the deleteMemory field.
func (r *mutationResolver) DeleteMemory(ctx context.Context, input string) (bool, error) {
	id, err := primitive.ObjectIDFromHex(input)
	if err != nil {
		return false, exception.ErrInvalidID
	}
	oldMemory, err := r.memorySvc.GetMemory(ctx, id)
	if err != nil {
		return false, err
	}
	err = r.memorySvc.DeleteMemory(ctx, id)
	err = r.resourceSvc.UpdateReferences(ctx, oldMemory.Content, "", input)
	if err != nil {
		return false, err
	}
	return true, nil
}

// AllMemories is the resolver for the allMemories field.
func (r *queryResolver) AllMemories(ctx context.Context, input generated.ListInput) ([]*memory.Memory, error) {
	memories, err := r.memorySvc.GetMemories(ctx, input.Page, input.Size, input.ByCreate, input.Desc, input.Archived)
	if err != nil {
		return nil, err
	}
	for _, m := range memories {
		m.Content, err = r.resourceSvc.InsertResourceUrl(ctx, m.Content)
		if err != nil {
			return nil, err
		}
	}
	return memories, nil
}

// Memory is the resolver for the memory field.
func (r *queryResolver) Memory(ctx context.Context, input string) (*memory.Memory, error) {
	id, err := primitive.ObjectIDFromHex(input)
	if err != nil {
		return nil, exception.ErrInvalidID
	}
	m, err := r.memorySvc.GetMemory(ctx, id)
	if err != nil {
		return nil, err
	}
	m.Content, err = r.resourceSvc.InsertResourceUrl(ctx, m.Content)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Memory returns generated.MemoryResolver implementation.
func (r *Resolver) Memory() generated.MemoryResolver { return &memoryResolver{r} }

type memoryResolver struct{ *Resolver }
