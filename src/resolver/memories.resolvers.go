package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"fmt"
	"time_speak_server/graph/generated"
	"time_speak_server/src/exception"
	"time_speak_server/src/service/memory"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// AddMemory is the resolver for the addMemory field.
func (r *mutationResolver) AddMemory(ctx context.Context, input generated.AddMemoryInput) (string, error) {
	// @auth
	if len(input.Content) == 0 {
		return "", exception.ErrContentEmpty
	}
	tags, err := r.hashtagSvc.MakeHashTags(ctx, input.Content)
	if err != nil {
		return "", err
	}
	memory, err := r.memorySvc.NewMemory(ctx, input.Title, input.Content, tags)
	if err != nil {
		return "", err
	}
	return memory, nil
}

// UpdateMemory is the resolver for the updateMemory field.
func (r *mutationResolver) UpdateMemory(ctx context.Context, input generated.UpdateMemoryInput) (bool, error) {
	if len(input.Content) == 0 {
		return false, exception.ErrContentEmpty
	}
	tags, err := r.hashtagSvc.MakeHashTags(ctx, input.Content)
	if err != nil {
		return false, err
	}
	id, err := primitive.ObjectIDFromHex(input.ID)
	if err != nil {
		return false, exception.ErrInvalidID
	}
	var toUpdate []memory.Option
	if len(input.Title) > 0 {
		toUpdate = append(toUpdate, memory.WithTitle(input.Title))
	}
	if len(input.Content) > 0 {
		toUpdate = append(toUpdate, memory.WithContent(input.Content))
		toUpdate = append(toUpdate, memory.WithTags(tags))
	}
	if len(toUpdate) == 0 {
		return true, nil
	}
	err = r.memorySvc.UpdateMemory(ctx, id, toUpdate...)
	return true, nil
}

// ArchiveMemory is the resolver for the archiveMemory field.
func (r *mutationResolver) ArchiveMemory(ctx context.Context, input string, archived bool) (bool, error) {
	id, err := primitive.ObjectIDFromHex(input)
	if err != nil {
		return false, exception.ErrInvalidID
	}
	toUpdate := memory.WithArchived(archived)
	err = r.memorySvc.UpdateMemory(ctx, id, toUpdate)
	return true, nil
}

// DeleteMemory is the resolver for the deleteMemory field.
func (r *mutationResolver) DeleteMemory(ctx context.Context, input string) (bool, error) {
	id, err := primitive.ObjectIDFromHex(input)
	if err != nil {
		return false, exception.ErrInvalidID
	}
	err = r.memorySvc.DeleteMemory(ctx, id)
	return true, nil
}

// AllMemories is the resolver for the allMemories field.
func (r *queryResolver) AllMemories(ctx context.Context, page int, size int, desc bool) ([]*generated.Memory, error) {
	panic(fmt.Errorf("not implemented: AllMemories - allMemories"))
}

// AllMemoriesByCreated is the resolver for the allMemoriesByCreated field.
func (r *queryResolver) AllMemoriesByCreated(ctx context.Context, page int, size int, desc bool) ([]*generated.Memory, error) {
	panic(fmt.Errorf("not implemented: AllMemoriesByCreated - allMemoriesByCreated"))
}

// ArchivedMemories is the resolver for the archivedMemories field.
func (r *queryResolver) ArchivedMemories(ctx context.Context, page int, size int, desc bool) ([]*generated.Memory, error) {
	panic(fmt.Errorf("not implemented: ArchivedMemories - archivedMemories"))
}

// Memory is the resolver for the memory field.
func (r *queryResolver) Memory(ctx context.Context, input string) (*generated.Memory, error) {
	panic(fmt.Errorf("not implemented: Memory - memory"))
}
